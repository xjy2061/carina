<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RGB_565 on Carina</title>
    <link>https://xjy2061.github.io/carina/tags/rgb_565/</link>
    <description>Recent content in RGB_565 on Carina</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Nov 2019 20:55:09 +0800</lastBuildDate><atom:link href="https://xjy2061.github.io/carina/tags/rgb_565/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Webp解码RGB_565问题记录</title>
      <link>https://xjy2061.github.io/carina/post/webp%E8%A7%A3%E7%A0%81rgb_565%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 30 Nov 2019 20:55:09 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/post/webp%E8%A7%A3%E7%A0%81rgb_565%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>最近遇到自定义webp解码使用rgb565时出现颜色错乱的问题，查了比较长时间，总结一下过程。
开始时怀疑代码逻辑有问题，于是写demo测试native代码逻辑，尝试修改Bitmap的一些属性，确认代码逻辑正确。
然后考虑到用系统解码api和官方ndk sample中的webp解码示例都正常，怀疑是不是对libwebp的调用方式有问题，于是去看源码。先从简单的ndk sample开始看，发现调用方式是一样的，然后看了系统webp解码部分源码，发现系统使用的解码函数不一样，尝试换成跟系统一样的函数，问题依然存在。由于官方示例并没有将图片解码成Bitmap，所以接着仔细看系统源码的解码过程，看是不是在某些细节里有特殊处理，最后没有发现有特殊的地方。
看了几天源码无果后，最后想到是不是解码得到的Bitmap的底层像素数据不一样，而不是对Bitmap的设置不一样，于是写测试代码获取Bitmap的像素字节数组，对2种方式解码得到的Bitmap的像素数据进行比较，发现同一像素的2个字节的位置刚好相反。
[74, 105, -125, -18, ...] [105, 74, -18, -125, ...] 到这里终于有点眉目了，后面就去找导致位置相反的原因，然后在libwebp源码定义像素格式的地方发现了一段注释，感觉很可能跟WEBP_SWAP_16BITS_CSP有关，但在代码中没有找到这个变量。
// ... // RGB-565: [r4 r3 r2 r1 r0 g5 g4 g3], [g2 g1 g0 b4 b3 b2 b1 b0], ... // In the case WEBP_SWAP_16BITS_CSP is defined, the bytes are swapped for // these two modes: // RGBA-4444: [b3 b2 b1 b0 a3 a2 a1 a0], [r3 r2 r1 r0 g3 g2 g1 g0], .</description>
    </item>
    
  </channel>
</rss>
