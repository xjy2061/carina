<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Carina</title>
    <link>https://xjy2061.github.io/carina/tags/android/index.xml</link>
    <description>Recent content in Android on Carina</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://xjy2061.github.io/carina/tags/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android memory leak</title>
      <link>https://xjy2061.github.io/carina/post/Android-memory-leak/</link>
      <pubDate>Sun, 10 Sep 2017 20:09:00 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/post/Android-memory-leak/</guid>
      <description>

&lt;h2 id=&#34;leak-because-of-system-bug&#34;&gt;Leak because of system bug&lt;/h2&gt;

&lt;h3 id=&#34;phonestatelistener-leak&#34;&gt;&lt;code&gt;PhoneStateListener&lt;/code&gt; leak&lt;/h3&gt;

&lt;p&gt;Below 7.0 a non static inner class &lt;code&gt;IPhoneStateListener.Stub&lt;/code&gt; callback in &lt;code&gt;PhoneStateListener&lt;/code&gt; references to outside &lt;code&gt;PhoneStateListener&lt;/code&gt;, even caller has been destroyed and &amp;ldquo;un-registered&amp;rdquo; the &lt;code&gt;PhoneStateListener&lt;/code&gt;, the references coming from: Native Stack &amp;ndash;&amp;gt; PhoneStateListener &amp;ndash;&amp;gt; Context(Activity).&lt;/p&gt;

&lt;p&gt;A wrapper class wraps a weak reference of &lt;code&gt;PhoneStateListener&lt;/code&gt; can be used to avoid this memory leak.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Caution: The original &lt;code&gt;PhoneStateListener&lt;/code&gt; object must be referenced by caller class, otherwise the weak reference in the wrapper class will get &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PhoneStateListenerWrapper extends PhoneStateListener {
    private WeakReference&amp;lt;PhoneStateListener&amp;gt; mPhoneStateListenerRef;

    public PhoneStateListenerWrapper(PhoneStateListener phoneStateListener) {
        mPhoneStateListenerRef = new WeakReference&amp;lt;&amp;gt;(phoneStateListener);
    }

    @Override
    public void onCallStateChanged(int state, String incomingNumber) {
        super.onCallStateChanged(state, incomingNumber);
        PhoneStateListener phoneStateListener = mPhoneStateListenerRef.get();
        if (phoneStateListener != null) {
            phoneStateListener.onCallStateChanged(state, incomingNumber);
        }
    }
}

private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
    @Override
    public void onCallStateChanged(int state, String incomingNumber) {
        super.onCallStateChanged(state, incomingNumber);
        //...
    }
};
private PhoneStateListenerWrapper mPhoneStateListenerWrapper = new PhoneStateListenerWrapper(mPhoneStateListener);

((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).listen(mPhoneStateListenerWrapper, PhoneStateListener.LISTEN_CALL_STATE);
((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).listen(mPhoneStateListenerWrapper, PhoneStateListener.LISTEN_NONE);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;audiomanager-leak&#34;&gt;&lt;code&gt;AudioManager&lt;/code&gt; leak&lt;/h3&gt;

&lt;p&gt;Below 6.0 &lt;code&gt;AudioManager&lt;/code&gt; reference to the incoming context of constructor directly, the related issue is &lt;a href=&#34;https://issuetracker.google.com/issues/37024105&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A simple workaround is using &lt;code&gt;Application&lt;/code&gt; context to get &lt;code&gt;AudioManager&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mAudioManager = (AudioManager) context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inputmethodmanager-leak&#34;&gt;&lt;code&gt;InputMethodManager&lt;/code&gt; leak&lt;/h3&gt;

&lt;p&gt;Refer to &lt;a href=&#34;https://issuetracker.google.com/issues/37043700&#34;&gt;issue 37043700&lt;/a&gt; and &lt;a href=&#34;https://issuetracker.google.com/issues/37090736&#34;&gt;issue 37090736&lt;/a&gt;, &lt;code&gt;mCurRootView&lt;/code&gt; or &lt;code&gt;mServedView&lt;/code&gt; or &lt;code&gt;mNextServedView&lt;/code&gt; in &lt;code&gt;InputMethodManager&lt;/code&gt; may reference to last focused view on a wide system version range. But I have not found this kind of leak in official system. However, &lt;code&gt;mLastSrvView&lt;/code&gt; of &lt;code&gt;InputMethodManager&lt;/code&gt; may cause leak on huawei 6.0 and above device, and &lt;code&gt;mLastSrvView&lt;/code&gt; field is not found in official source code, I think this is a leak for certain manufacturer.&lt;/p&gt;

&lt;p&gt;To fix this kind of leak, a straight way is set the relative field of &lt;code&gt;InputMethodManager&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; when activity destroyed. Considering there may be multiple activities have this leak, a better way is fix this leak in the &lt;code&gt;onActivityDestroyed(Activity activity)&lt;/code&gt; method of &lt;code&gt;ActivityLifecycleCallbacks&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onActivityDestroyed(Activity activity) {
	MemoryLeakFixer.fixInputMethodManagerLeak(activity);
}

public class MemoryLeakFixer {

    public static void fixInputMethodManagerLeak(Activity activity) {
        //Surround with a appropriate if condition to make sure execute fix when leak real exists is better.
        InputMethodManager inputMethodManager = null;
        try {
            inputMethodManager = (InputMethodManager) activity.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        if (inputMethodManager!= null) {
            String[] fieldNames = new String[]{&amp;quot;mCurRootView&amp;quot;, &amp;quot;mServedView&amp;quot;, &amp;quot;mNextServedView&amp;quot;, &amp;quot;mLastSrvView&amp;quot;/*huawei*/};
            Class clazz = inputMethodManager.getClass();
            for (String fieldName : fieldNames) {
                try {
                    Field field = clazz.getDeclaredField(fieldName);
                    if (field != null) {
                        if (!field.isAccessible()) {
                            field.setAccessible(true);
                        }
                        Object obj = field.get(inputMethodManager);
                        if (obj instanceof View) {
                            View view = (View) obj;
                            if (view.getContext() == activity) {
                                field.set(inputMethodManager, null);
                            }
                        }
                    }
                } catch (Throwable t) {
                    t.printStackTrace();
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;textline-leak&#34;&gt;&lt;code&gt;TextLine&lt;/code&gt; leak&lt;/h3&gt;

&lt;p&gt;An activity context may be referenced by &lt;code&gt;sCached&lt;/code&gt; in &lt;code&gt;TextLine&lt;/code&gt;, a simple solution is set every element of &lt;code&gt;sCached&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; in activity&amp;rsquo;s &lt;code&gt;onDestroy&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void fixTextLineLeak() {
    try {
        Field field = Class.forName(&amp;quot;android.text.TextLine&amp;quot;).getDeclaredField(&amp;quot;sCached&amp;quot;);
        field.setAccessible(true);
        Object[] sCached = (Object[]) field.get(null);
        if (sCached != null) {
            for (int i = 0; i &amp;lt; sCached.length; i++) {
                sCached[i] = null;
            }
        }
    } catch (Throwable t) {
        t.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;leak-because-of-misuse&#34;&gt;Leak because of misuse&lt;/h2&gt;

&lt;h3 id=&#34;unremoved-viewtreeobserver-listener-leak&#34;&gt;Unremoved &lt;code&gt;ViewTreeObserver&lt;/code&gt; listener leak&lt;/h3&gt;

&lt;p&gt;The scenario is after create a new item view for a &lt;code&gt;ViewPager&lt;/code&gt; by the &lt;code&gt;instantiateItem&lt;/code&gt; method of &lt;code&gt;PageAdapter&lt;/code&gt;, a listener reference to the item view indirectly have been add to the &lt;code&gt;ViewTreeObserver&lt;/code&gt; of the item view, and the listener never be removed from the &lt;code&gt;ViewTreeObserver&lt;/code&gt;, cause the item view leak even the view has been removed from the view hierarchy in the &lt;code&gt;destroyItem&lt;/code&gt; method of &lt;code&gt;PageAdapter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Never forgot remove listeners from &lt;code&gt;ViewTreeObserver&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final ViewTreeObserver observer = view.getViewTreeObserver();
if (observer != null) {
	observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
	    @Override
	    public void onGlobalLayout() {
    	    //do something
			if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.JELLY_BEAN) {
				observer.removeOnGlobalLayoutListener(this);
			} else {
				observer.removeGlobalOnLayoutListener(this);
			}
		}
	});
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android command line</title>
      <link>https://xjy2061.github.io/carina/note/Android-command-line/</link>
      <pubDate>Sat, 29 Apr 2017 18:54:21 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/note/Android-command-line/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Show current tasks&lt;/strong&gt;&lt;br /&gt;
adb shell dumpsys activity activites&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Show screen infos&lt;/strong&gt;&lt;br /&gt;
adb shell dumpsys window&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Show gfxinfo&lt;/strong&gt;&lt;br /&gt;
adb shell dumpsys gfxinfo &amp;lt;PACKAGE_NAME&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Android tips</title>
      <link>https://xjy2061.github.io/carina/note/Android-tips/</link>
      <pubDate>Sat, 29 Apr 2017 18:08:07 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/note/Android-tips/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果要在低版本系统上使用高版本系统才加入的类，可以在app中加入同名类，在高版本系统上安装时这个同名类会删除，还是使用系统的类，在低版本系统则使用在app中加入的类。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在不同的&lt;code&gt;PendingIntent&lt;/code&gt;的&lt;code&gt;Intent&lt;/code&gt;中设置extra，在处理&lt;code&gt;Intent&lt;/code&gt;的地方获取的extra始终相同，可以通过设置不同RequestCode来区分不同的&lt;code&gt;PendingIntent&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于replace fragment，通过代码和通过配置文件加入最初的fragment这两种方式之间是有区别的，当通过代码的加入最初的fragment时，replace一个新的fragment后再回退，会调最初的fragment的onCreateView方法，说明replace时最初的fragment被销毁了，而通过配置文件的方法则不会调用onCreateView方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在xml中加入fragment时键盘会自动弹出，通过代码加入时不会。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AsyncTask&lt;/code&gt;在3.0以前是并行执行的，3.0及以后顺序执行的，&lt;code&gt;AsyncTask&lt;/code&gt;是通过静态的&lt;code&gt;Handler&lt;/code&gt;成员变量将结果post到主线程中执行的，所以要确保加载&lt;code&gt;AsyncTask&lt;/code&gt;类是在主线程中执行的，在4.1及以后系统已经确保的这一点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果自己decode ninepatch图片，要先compile ninepatch图片。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;android ListView Adapter&amp;rsquo;s getView method sometimes provide a wrong type convertView. &lt;a href=&#34;http://stackoverflow.com/questions/12018997/why-does-getview-return-wrong-convertview-objects-on-separatedlistadapter&#34;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;市场解锁、gaeproxy等软件会修改运营商信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cookie里包含有特殊字符会导致请求失败。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bitmap.createBitmap在低内存时在有些手机上可能返回null，而不是抛OutofMemoryError。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于apk压缩包的操作应使用android自带的aapt，避免直接使用zip，直接使用zip会将apk里面的raw资源压缩，导致有些rom下读取raw文件失败。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果不给&lt;code&gt;WebView&lt;/code&gt;设置&lt;code&gt;WebViewClient&lt;/code&gt;，在有些手机上会自动跳到系统浏览器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Create avd and start app with command line</title>
      <link>https://xjy2061.github.io/carina/post/Create-avd-and-start-app-with-command-line/</link>
      <pubDate>Tue, 21 Mar 2017 12:23:32 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/post/Create-avd-and-start-app-with-command-line/</guid>
      <description>

&lt;h2 id=&#34;install-sdk-create-or-delete-avd&#34;&gt;Install sdk, create or delete avd&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;android list sdk -a
android update sdk -a -u --filter [id1, id2]

android list targets
android create avd -n 4.1-x86 -t 1 -b x86 -c 512M

android delete avd -n 4.1-x86
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;start-emulator-and-launch-app&#34;&gt;Start emulator and launch app&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;android list avd
emulator64-x86 -avd 4.1-x86 -no-window -no-boot-anim -qemu -m 1024 -enable-kvm &amp;amp;

adb shell am start fm.xiami.main/fm.xiami.bmamba.activity.StartActivity

adb forward tcp:11874 tcp:11873
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on 64-bits machines you may need install ia32-libs to run adb:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install ia32-libs
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>VectorDrawable clip path</title>
      <link>https://xjy2061.github.io/carina/post/VectorDrawable-clip-path/</link>
      <pubDate>Tue, 14 Mar 2017 11:54:56 +0800</pubDate>
      
      <guid>https://xjy2061.github.io/carina/post/VectorDrawable-clip-path/</guid>
      <description>

&lt;h2 id=&#34;function&#34;&gt;Function&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;clip path&lt;/strong&gt;限制在画布上绘制的区域，在&lt;strong&gt;clip path&lt;/strong&gt;所指定的区域外的位置不会被绘制。&lt;/p&gt;

&lt;p&gt;我们通过下面的心形图标来展示&lt;strong&gt;clip path&lt;/strong&gt;的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;vector
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:width=&amp;quot;56dp&amp;quot;
    android:height=&amp;quot;56dp&amp;quot;
    android:viewportHeight=&amp;quot;56&amp;quot;
    android:viewportWidth=&amp;quot;56&amp;quot;&amp;gt;

  &amp;lt;path
      android:fillColor=&amp;quot;@android:color/black&amp;quot;
      android:pathData=&amp;quot;M28,39 L26.405,37.5667575 C20.74,32.4713896 17,29.1089918 17,24.9945504 C17,21.6321526 19.6565,19 23.05,19 C24.964,19 26.801,19.8828338 28,21.2724796 C29.199,19.8828338 31.036,19 32.95,19 C36.3435,19 39,21.6321526 39,24.9945504 C39,29.1089918 35.26,32.4713896 29.595,37.5667575 L28,39 L28,39 Z&amp;quot;/&amp;gt;

&amp;lt;/vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;heart.png&#34; alt=&#34;heart&#34; /&gt;&lt;br /&gt;
&lt;font size=3&gt;&lt;strong&gt;Figure1&lt;/strong&gt; 心形图标&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;下面加入&lt;code&gt;&amp;lt;clip-path&amp;gt;&lt;/code&gt;将绘制区域限制在[0, 0, 56, 28]的矩形区域内：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;vector
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:width=&amp;quot;56dp&amp;quot;
    android:height=&amp;quot;56dp&amp;quot;
    android:viewportHeight=&amp;quot;56&amp;quot;
    android:viewportWidth=&amp;quot;56&amp;quot;&amp;gt;

  &amp;lt;clip-path
      android:name=&amp;quot;clip&amp;quot;
      android:pathData=&amp;quot;M0 0 L56 0 L56 28 L0 28 Z&amp;quot;/&amp;gt;

  &amp;lt;path
      android:fillColor=&amp;quot;@android:color/black&amp;quot;
      android:pathData=&amp;quot;M28,39 L26.405,37.5667575 C20.74,32.4713896 17,29.1089918 17,24.9945504 C17,21.6321526 19.6565,19 23.05,19 C24.964,19 26.801,19.8828338 28,21.2724796 C29.199,19.8828338 31.036,19 32.95,19 C36.3435,19 39,21.6321526 39,24.9945504 C39,29.1089918 35.26,32.4713896 29.595,37.5667575 L28,39 L28,39 Z&amp;quot;/&amp;gt;

&amp;lt;/vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;clip-heart.png&#34; alt=&#34;clip-heart&#34; /&gt;&lt;br /&gt;
&lt;font size=3&gt;&lt;strong&gt;Figure2&lt;/strong&gt; clip后的心形图标&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;application&#34;&gt;Application&lt;/h2&gt;

&lt;p&gt;可通过改变&lt;code&gt;&amp;lt;clip-path&amp;gt;&lt;/code&gt;的&lt;code&gt;pathData&lt;/code&gt;值来实现一些动画效果。&lt;/p&gt;

&lt;p&gt;下面通过&lt;strong&gt;clip path&lt;/strong&gt;来实现填充心形图标的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;animated-vector
  xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:aapt=&amp;quot;http://schemas.android.com/aapt&amp;quot;
  android:drawable=&amp;quot;@drawable/vd_trimclip_heart_full&amp;quot;&amp;gt;

  &amp;lt;target android:name=&amp;quot;clip&amp;quot;&amp;gt;
    &amp;lt;aapt:attr name=&amp;quot;android:animation&amp;quot;&amp;gt;
      &amp;lt;objectAnimator
        android:duration=&amp;quot;@android:integer/config_mediumAnimTime&amp;quot;
        android:interpolator=&amp;quot;@android:interpolator/fast_out_slow_in&amp;quot;
        android:propertyName=&amp;quot;pathData&amp;quot;
        android:valueFrom=&amp;quot;M18 37 L38 37 L38 37 L18 37 Z&amp;quot;
        android:valueTo=&amp;quot;M0 0 L56 0 L56 56 L0 56 Z&amp;quot;
        android:valueType=&amp;quot;pathType&amp;quot;/&amp;gt;
    &amp;lt;/aapt:attr&amp;gt;
  &amp;lt;/target&amp;gt;

&amp;lt;/animated-vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vd_trimclip_heart_full.xml：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;vector
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:width=&amp;quot;56dp&amp;quot;
    android:height=&amp;quot;56dp&amp;quot;
    android:tint=&amp;quot;?attr/colorControlNormal&amp;quot;
    android:viewportHeight=&amp;quot;56&amp;quot;
    android:viewportWidth=&amp;quot;56&amp;quot;&amp;gt;

  &amp;lt;path
      android:pathData=&amp;quot;M28.7194825,38.2960196 L25.6688233,35.5523072 C21.6213379,31.793335 18.0159912,28.8906251 18.0159912,24.845337 C18.0159912,21.5882568 20.6305373,19.9651315 23.6337891,19.9651442 C24.9985352,19.96515 26.7993165,21.180664 28.643982,23.1297608&amp;quot;
      android:strokeColor=&amp;quot;@android:color/white&amp;quot;
      android:strokeWidth=&amp;quot;2&amp;quot;/&amp;gt;

  &amp;lt;path
      android:pathData=&amp;quot;M27.2310342,38.2944327 L30.7645263,35.2004395 C34.8336142,31.2354829 37.751709,29.1181308 38.0040283,25.0838624 C38.1681943,22.4590544 35.7730552,20.034668 33.3791503,20.034668 C30.4320068,20.034668 29.671997,21.0472412 27.2310342,23.1328126&amp;quot;
      android:strokeColor=&amp;quot;@android:color/white&amp;quot;
      android:strokeWidth=&amp;quot;2&amp;quot;/&amp;gt;

  &amp;lt;group android:name=&amp;quot;filled&amp;quot;&amp;gt;
    &amp;lt;clip-path
        android:name=&amp;quot;clip&amp;quot;
        android:pathData=&amp;quot;M18 37 L38 37 L38 37 L18 37 Z&amp;quot;/&amp;gt;
    &amp;lt;path
        android:fillColor=&amp;quot;@android:color/white&amp;quot;
        android:pathData=&amp;quot;M28,39 L26.405,37.5667575 C20.74,32.4713896 17,29.1089918 17,24.9945504 C17,21.6321526 19.6565,19 23.05,19 C24.964,19 26.801,19.8828338 28,21.2724796 C29.199,19.8828338 31.036,19 32.95,19 C36.3435,19 39,21.6321526 39,24.9945504 C39,29.1089918 35.26,32.4713896 29.595,37.5667575 L28,39 L28,39 Z&amp;quot;/&amp;gt;
  &amp;lt;/group&amp;gt;

&amp;lt;/vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;fill-heart.gif&#34; alt=&#34;fill-heart&#34; /&gt;&lt;br /&gt;
&lt;font size=3&gt;&lt;strong&gt;Figure3&lt;/strong&gt; 心形图标填充效果&lt;/font&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>